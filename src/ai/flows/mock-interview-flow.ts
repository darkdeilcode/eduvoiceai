'use server';

/**
 * @fileOverview Simulates a mock interview with an AI interviewer.
 * This flow generates the first question for a mock interview.
 * Implements a cascading API key fallback: User Gemini -> Platform Default.
 *
 * - getFirstInterviewQuestion - A function that generates the first interview question.
 * - InterviewConfigInput - The input type for generating the question (resume, job description, optional API keys).
 * - FirstQuestionOutput - The return type, containing the first question.
 */

import { genkit as baseGenkit } from 'genkit';
import { googleAI } from '@genkit-ai/googleai';
import { ai } from '@/ai/genkit'; // Global AI instance
import { z } from 'genkit';

const InterviewConfigInputSchema = z.object({
  resume: z
    .string()
    .describe('The resume of the candidate, as a data URI that must include a MIME type and use Base64 encoding. Expected format: \'data:<mimetype>;base64,<encoded_data>\'.'),
  jobDescription: z.string().describe('The job description for the role the candidate is interviewing for.'),
  geminiApiKey: z.string().optional().describe('Optional Google Gemini API key to use for this request.'),
  openaiApiKey: z.string().optional().describe('Optional OpenAI API key to use for this request (currently not supported by this flow).'),
  claudeApiKey: z.string().optional().describe('Optional Anthropic Claude API key to use for this request (currently not supported).'),
});
export type InterviewConfigInput = z.infer<typeof InterviewConfigInputSchema>;

const FirstQuestionOutputSchema = z.object({
  firstQuestion: z.string().describe("The first interview question generated by the AI interviewer based on the candidate's resume and the job description, including a brief opening greeting."),
});
export type FirstQuestionOutput = z.infer<typeof FirstQuestionOutputSchema>;

const PromptDataTypeSchema = z.object({
    resume: z.string(),
    jobDescription: z.string(),
});

const FIRST_QUESTION_PROMPT_TEMPLATE = `You are an AI Interviewer.
Based on the candidate's resume and the provided job description, your task is to:
1. Start with a brief, professional opening greeting (e.g., "Hello! I'm your AI interviewer for today. Let's begin with your first question.").
2. Generate the *first* relevant interview question to start the mock interview.

Job Description:
{{jobDescription}}

Candidate's Resume:
{{resume}}

Please provide the greeting followed by the first question as a single string.
`;

async function generateFirstQuestionLogic(input: InterviewConfigInput): Promise<FirstQuestionOutput> {
  const promptData: z.infer<typeof PromptDataTypeSchema> = { 
    resume: input.resume, 
    jobDescription: input.jobDescription 
  };

  // Try user-provided Gemini API key first
  if (input.geminiApiKey) {
    console.log(`Attempting to use user-provided Gemini API key for first interview question.`);
    try {
      const tempAi = baseGenkit({
        plugins: [googleAI({ apiKey: input.geminiApiKey })],
      });
      
      const tempGenerate = tempAi.defineFlow(
        {
          name: `tempFirstQuestionFlow_${Date.now()}`,
          inputSchema: PromptDataTypeSchema,
          outputSchema: FirstQuestionOutputSchema,
        },
        async (data) => {
          const prompt = FIRST_QUESTION_PROMPT_TEMPLATE
            .replace(/\{\{jobDescription\}\}/g, data.jobDescription)
            .replace(/\{\{resume\}\}/g, data.resume);
          
          const result = await tempAi.generate({
            model: 'googleai/gemini-1.5-flash',
            prompt: prompt,
            output: { schema: FirstQuestionOutputSchema },
          });
          
          if (!result.output) {
            throw new Error('Model returned no output');
          }
          
          return result.output;
        }
      );

      const response = await tempGenerate(promptData);
      if (!response) {
        throw new Error('Model (Gemini) returned no output.');
      }

      console.log(`Successfully used user-provided Gemini API key for first question.`);
      return response;
    } catch (e: any) {
      console.warn(`Error using user-provided Gemini API key for first question:`, e.message);
      const errorMessage = (e.message || "").toLowerCase();
      const errorStatus = e.status || e.code;
      const errorType = (e.type || "").toLowerCase();
      const isKeyError =
        errorMessage.includes("api key") ||
        errorMessage.includes("permission denied") ||
        errorMessage.includes("quota exceeded") ||
        errorMessage.includes("authentication failed") ||
        errorMessage.includes("invalid_request") ||
        errorMessage.includes("billing") ||
        errorMessage.includes("insufficient_quota") ||
        errorType.includes("api_key") ||
        errorStatus === 401 || errorStatus === 403 || errorStatus === 429 ||
        (e.cause && typeof e.cause === 'object' && 'code' in e.cause && e.cause.code === 7) ||
        (e.response && e.response.data && e.response.data.error && /api key/i.test(e.response.data.error.message));
      
      if (!isKeyError) throw e;
      console.log(`User's Gemini API key failed. Falling back to platform default.`);
    }
  }

  console.log("Falling back to platform's default API key for first interview question.");
  try {
    const prompt = FIRST_QUESTION_PROMPT_TEMPLATE
      .replace(/\{\{jobDescription\}\}/g, promptData.jobDescription)
      .replace(/\{\{resume\}\}/g, promptData.resume);
    
    const result = await ai.generate({
      model: 'googleai/gemini-1.5-flash',
      prompt: prompt,
      output: { schema: FirstQuestionOutputSchema },
    });

    if (!result.output) {
      throw new Error("AI model did not return the expected output for the first question.");
    }
    
    return result.output;
  } catch (fallbackError: any) {
    console.error("Error during platform fallback:", fallbackError);
    throw new Error(`Platform fallback for first question failed: ${fallbackError.message || 'Unknown error during fallback'}`);
  }
}

const firstQuestionFlow = ai.defineFlow(
  {
    name: 'firstQuestionFlow',
    inputSchema: InterviewConfigInputSchema,
    outputSchema: FirstQuestionOutputSchema,
  },
  generateFirstQuestionLogic
);

export async function getFirstInterviewQuestion(input: InterviewConfigInput): Promise<FirstQuestionOutput> {
  return firstQuestionFlow(input);
}